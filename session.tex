\section{Connection to Multi-Party Session Types}
\label{sec:mpst-connection}

This section gives a deliberately lightweight correspondence between \KFOL\ prefixes and MPST-style global protocols. In contrast to event-structure-based accounts that relate session types and game semantics in a fully concurrent and branching setting (e.g.\ \cite{CastellanYoshidaSessionGame}), we stay in a \emph{linear, non-branching, choreography-style} fragment and make visibility explicit in the protocol itself.

This translation is purely structural: it preserves the linear order of moves and the visibility/multiparty delivery pattern, but it forgets the K-ary payoff tuple. Certain game-theoretic notions (e.g. forceability of a given role) might be representable on top of a more expressive or MPST discipline, but our translation here is deliberately shape-only and we do not attempt to recover such notions from the MPST side.

\subsection{Setting}

We fix th
We fix the participant set
\[
  \mathcal{P} = \{0,1,\dots,K-1\}
\]
to coincide with the \KFOL\ players. Every bound variable $x$ is assigned an MPST ground sort $U_x$. We require the well-formedness condition
\[
  P_i x \setminus V.\,\Phi \text{ is allowed only if } i \in \mathcal{P} \text{ and } V \subseteq \mathcal{P} \setminus \{i\}.
\]
Intuitively, player $i$ chooses $x$, and exactly the roles in $\mathcal{P} \setminus (\{i\} \cup V)$ may observe that choice.

\paragraph{Target global types.}
Let $\mathsf{Glob}$ denote the set of \emph{linear MPST-style global types} generated by
\[
  \mathsf{Glob} ::= \mathbf{end}
      \mid (p \to q : U)\,;\,\mathsf{Glob}
\]
where $p,q \in \mathcal{P}$ and $U$ is a ground sort. Thus $\mathsf{Glob}$ contains only
point-to-point sends in sequence and terminates in $\mathbf{end}$; there is no
branching or concurrency. Our translation $\mathcal{T} : \KFOL \to \mathsf{Glob}$ will land
in this fragment.

\subsection{Core Analogy}

\begin{center}
\begin{tabular}{ll}
\hline
\textbf{\KFOL} & \textbf{MPST} \\ \hline
Players $\{0,\dots,K-1\}$ & Participants $\mathcal{P}$ \\
Linear binder prefix & Global type (linear sequence) \\
Binder $P_i x \setminus V.\,\cdot$ & $i$ sends $x$ to a subset of participants \\
Terminal $\langle \fo_0,\dots,\fo_{K-1}\rangle$ & $\mathbf{end}$ \\ \hline
\end{tabular}
\end{center}

We encode only the communication skeleton; the payoff tuple is erased.

\subsection{Broadcasting as Multiple Messages}
Standard MPST have no built-in support for broadcasting (but see \cite{cano2019multiparty} and \cite{kouzapas2014session}). We encode broadcasting into series of messages, and add the assumption of common knowledge between recipients, which is crucial for reasoning about strategy profiles and equilibria.

For $i \in \mathcal{P}$, a sort $U$, and $S \subseteq \mathcal{P} \setminus \{i\}$, write
\[
  \BCast{i}{U}{S}
\]
for the sequence of point-to-point sends from $i$ to each $j \in S$, in some fixed but arbitrary order:
\[
  \BCast{i}{U}{\{j_1,\dots,j_m\}}
  \;=\;
  (i \to j_1 : U)\,;\,(i \to j_2 : U)\,;\,\dots\,;\,(i \to j_m : U).
\]
Define the empty case by
\[
  \BCast{i}{U}{\emptyset} := \epsilon.
\]

Note that $\BCastOp$ here is only a shorthand for a sequence of point-to-point sends. In \KFOL\ the corresponding binder is a single atomic game move that is immediately visible to all non-slashed roles; plain MPST does not enforce or assume this common-knowledge aspect, and we rely on the game semantics (meta level) for that.

\subsection{Two Translation Schemes}
It is helpful to name both the ``everyone sees'' encoding and the visibility-restricting one, and then fix the latter.

\begin{definition}[Broadcast-based translation $\mathcal{T}^{\mathsf{bcast}}$]
\label{def:mpst-bcast}
Define $\mathcal{T}^{\mathsf{bcast}} : \KFOL \to \mathsf{Glob}$ by
\[
\begin{aligned}
\mathcal{T}^{\mathsf{bcast}}\bigl(\langle \fo_0,\dots,\fo_{K-1}\rangle\bigr)
  &:= \mathbf{end},\\
\mathcal{T}^{\mathsf{bcast}}\bigl(P_i x \setminus V.\,\Phi\bigr)
  &:= \BCast{i}{U_x}{\mathcal{P} \setminus \{i\}} \;;\; \mathcal{T}^{\mathsf{bcast}}(\Phi).
\end{aligned}
\]
This ignores the slash set $V$ at the protocol level; enforcing ``you must not depend on $V$'' would then be pushed to a separate strategy-validity layer.
\end{definition}

\begin{definition}[Visibility-restricting translation $\mathcal{T}$ (chosen)]
\label{def:mpst-vis}
Define $\mathcal{T} : \KFOL \to \mathsf{Glob}$ by
\[
\begin{aligned}
\mathcal{T}\bigl(\langle \fo_0,\dots,\fo_{K-1}\rangle\bigr)
  &:= \mathbf{end},\\
\mathcal{T}\bigl(P_i x \setminus V.\,\Phi\bigr)
  &:= \BCast{i}{U_x}{(\mathcal{P} \setminus \{i\}) \setminus V} \;;\; \mathcal{T}(\Phi).
\end{aligned}
\]
So a slashed role simply does not receive the message.
\end{definition}

This is the analogue, in our simplified setting, of ``putting the game-relevant structure in the type'' rather than in an external semantic notion of strategy, in the spirit of \cite{CastellanYoshidaSessionGame}, but for a strictly less expressive fragment.

\subsection{Projection to Local Types}

Let $\mathsf{Glob} = \mathcal{T}(\Phi)$. For each $p \in \mathcal{P}$ we take the standard MPST projection and write $\mathsf{Glob} \upharpoonright_p$. We use the conventional local notation
\[
\begin{aligned}
  !j\langle U\rangle &\text{ = send to $j$ a value of sort $U$}, \\
  ?j\langle U\rangle &\text{ = receive from $j$ a value of sort $U$}.
\end{aligned}
\]
For a single binder $P_i x \setminus V$ we obtain:

\begin{itemize}
  \item $\mathsf{Glob} \upharpoonright_i$ contains sends $!j\langle U_x\rangle$ to every $j \in (\mathcal{P} \setminus \{i\}) \setminus V$;
  \item for every $j \in (\mathcal{P} \setminus \{i\}) \setminus V$, $\mathsf{Glob} \upharpoonright_j$ contains a receive $?i\langle U_x\rangle$;
  \item for every $j \in V$, $\mathsf{Glob} \upharpoonright_j$ contains no communication action for this binder.
\end{itemize}

\begin{example}[Two players]
Let
\[
  \Phi = P_0 x \setminus \emptyset.\, P_1 y \setminus \{0\}.\, \langle \fo_0,\fo_1\rangle,
\]
with $x : U_x$ and $y : U_y$. Then
\[
  \mathcal{T}(\Phi)
  = (0 \to 1 : U_x) \;;\; \BCast{1}{U_y}{\emptyset} \;;\; \mathbf{end}
  = (0 \to 1 : U_x) \;;\; \mathbf{end}.
\]
Projection yields
\[
  \mathcal{T}(\Phi) \upharpoonright_0 = !1\langle U_x\rangle;\ \mathbf{end},
  \qquad
  \mathcal{T}(\Phi) \upharpoonright_1 = ?0\langle U_x\rangle;\ \mathbf{end}.
\]
Player 1's move $y$ does occur in the \KFOL\ game but is not communicated to player 0 in the protocol, exactly because of the slash set $\{0\}$.
\end{example}

\paragraph{A conjectured logical--session correspondence.}
Fix $\Phi$ over participants $\{0,\dots,K-1\}$ and fix $p$. Let
\[
  \pi_p : \{0,\dots,K-1\} \twoheadrightarrow \{A,B\}
  \quad\text{be the surjection with}\quad
  \pi_p(p) = A \text{ and } \pi_p(j) = B \text{ for } j \neq p.
\]
Apply the adversarial projection:
\[
  \psi_p \;:=\; \AdvProj{p}{\Phi},
\]
obtaining a prenex \FOL\ formula that expresses $\Phi$ from $p$'s
viewpoint.

On the session side, translate $\Phi$ to a global type and project it:
\[
  L_p \;:=\; (\mathcal T(\Phi))!\upharpoonright_p.
\]

\emph{Conjecture.} For every $\Phi$ and $p$,
the local session type $L_p$ describes the same $p$-view of the
interaction as the logical adversarial projection $\AdvOp$, up to role
renaming and erasure of the terminal payoff. In symbols,
\[
  (\mathcal T(\Phi)) \upharpoonright_p \;\equiv\;
  \mathcal T^{(2)}\bigl(\CoalProjOr{\pi_p}(\Phi)\bigr),
\]
and $\AdvProj{A}{\CoalProjOr{\pi_p}(\Phi)}$ is the corresponding 2-player,
FOL-level viewpoint.
We do not prove this; the inductive cases match the translation rules
binder-by-binder but require bookkeeping on the visibility sets.

\subsection{Scope}

This correspondence is intentionally weaker than the session-type/game-semantics correspondence based on (coincident) event structures in \cite{CastellanYoshidaSessionGame}: we do not treat branching/selection, concurrency, or the synchrony–asynchrony gap; we only show that a linear \KFOL\ prefix with explicit visibility can be read as a linear MPST global whose projection is standard. Since the target is an ordinary MPST global, the usual projection/duality/progress properties of MPST apply to the translated protocol; what we erase is the \KFOL\ terminal payoff tuple, which we map to $\mathbf{end}$.

The point of this section is only to show that every \KFOL protocol has an MPST-shaped carrier. It is not a full-abstraction result: MPST typing of the translated protocol does not recover or validate the original per-player objectives.

\subsection{A Faithful Projection into Refined MPST (Best-Effort)}
\label{sec:best-effort-rmpst}

We now spell out a concrete projection from \KFOL\ to a refined
multiparty-session--style global description. The goal is not to show that
\KFOL\ is more expressive than refined MPST, but to identify precisely which
parts of our specifications survive such a projection and which parts remain
specific to the game-theoretic reading.

\paragraph{Source.}
Recall that a closed \KFOL{} formula has the shape
\[
  \Phi \;=\; P_{i_1} x_1 \setminus V_1.\; \dots.\; P_{i_n} x_n \setminus V_n.\;
  \langle \varphi_0,\dots,\varphi_{K-1} \rangle
\]
where each binder says “player \(i_k\) chooses a value for \(x_k\), and roles in
\(V_k\) do not see this move,” and the terminal is a \(K\)-tuple of
first-order goals. The semantics evaluates this prefix once, centrally, and
then produces a \(K\)-vector of truth values.

\paragraph{Target.}
We project \(\Phi\) to a refined MPST global \(\mathcal{G}(\Phi)\) over the same
participant set \(\mathcal{P} = \{0,\dots,K-1\}\). A refined MPST global here is
a sequence of labelled communications, each optionally decorated with a
first-order refinement that must hold at that point. Ordinary MPST uses
point-to-point channels; because our source has broadcast-style visibility, we
use a “multi-send” sugar in the target, which can be compiled to a sequence of
ordinary sends.

\paragraph{Step 1: interaction projection.}
We project the prefix position-by-position. For a binder
\[
  P_i x \setminus V.\,\Psi
\]
we introduce, in order, a family of sends
\[
  i \to j : U_x \{ \rho_{i,x} \}
  \qquad \text{for every } j \in \mathcal{P} \setminus (\{i\} \cup V),
\]
and skip the slashed roles \(j \in V\) altogether. Here \(U_x\) is the sort of
\(x\). This is the refined version of the visibility-restricting translation
from \Cref{sec:mpst-connection}: everyone who is not slashed receives the value.

What remains is to say what refinement \(\rho_{i,x}\) is. In full generality our
terminal may mention variables not yet in scope at this binder, so we extract
only the part that is \emph{checkable now}. Concretely, let
\(\mathrm{FV}_{\le k}\) be the variables bound \emph{up to} this binder (i.e.\
\(\{x_1,\dots,x_k\}\)). For each player \(i\), define the \emph{binder-local
projection} of \(\varphi_i\) at position \(k\) by
\[
  \pi^{\text{local}}_{i,k}(\varphi_i)
  \;:=\;
  \bigwedge \{ \chi \mid \chi \text{ is a conjunct of } \varphi_i
                    \text{ and } \mathrm{FV}(\chi) \subseteq \mathrm{FV}_{\le k} \}.
\]
(If \(\varphi_i\) is not a conjunction, first put it in an equivalent CNF
restricted to earlier variables; otherwise this set is empty and the
conjunction is \(\top\).) We then set
\[
  \rho_{i,x} \;:=\; \bigwedge_{p \in \mathcal{P}} \pi^{\text{local}}_{p,k}(\varphi_p).
\]
So the refinement attached to this send is “all binder-local constraints that
are already meaningful at this point,” aggregated over all players. This is
exactly the kind of per-action refinement that R-MPST carries.

Applying this clause to every binder in the prefix yields a refined global
\(\mathcal{G}_{\mathrm{prefix}}(\Phi)\) with the same linear order of moves and
the same visibility pattern.

\paragraph{Step 2: per-role dummy commitments.}
The terminal \(\langle \varphi_0,\dots,\varphi_{K-1} \rangle\) can contain
constraints that are \emph{not} checkable at any earlier binder (for example,
because they refer to all players’ choices at once). To make these visible in
the session world without breaking locality, we append, for every participant
\(i\), a dummy action of the form
\[
  i \to \text{unit} : \mathtt{unit} \{ \varphi_i^\mathrm{residual} \}
\]
where \(\varphi_i^\mathrm{residual}\) is the part of \(\varphi_i\) that was
\emph{not} captured by any of the \(\rho_{-, -}\) above. Operationally this is “I
perform a no-op but I assert my remaining condition.” This brings each
player-specific formula into the refined MPST surface form: every participant
now has a final, local refinement.

At this point we have a refined MPST global
\[
  \mathcal{G}(\Phi) \;=\; \mathcal{G}_{\mathrm{prefix}}(\Phi) \,;\,
                          \prod_{i \in \mathcal{P}} \bigl(i \to \text{unit} : \mathtt{unit} \{ \varphi_i^\mathrm{residual} \}\bigr)
\]
(where the final product can be sequenced in any fixed order).

\paragraph{What this preserves.}
This projection preserves:
\begin{itemize}[nosep]
  \item the \emph{linear order} of moves;
  \item the \emph{assignment of moves to participants};
  \item the \emph{visibility pattern} expressed by slash-sets (as recipients are
        omitted);
  \item all \emph{binder-local} logical conditions that are expressible over the
        variables in scope at that point;
  \item and the fact that there are \emph{per-role} logical obligations at the
        end (via the dummy steps).
\end{itemize}
A refined-MPST toolchain that projects globals to endpoints and checks
admissible traces would be able to enforce precisely these parts.

\paragraph{What this does \emph{not} preserve.}
Two aspects of \KFOL{} do \emph{not} survive this projection:

\begin{enumerate}[nosep]
  \item \textbf{Outcome-as-value.} In \KFOL{} the terminal yields a
        \(\{0,1\}^K\) vector which we later feed to solution concepts (forceability,
        IR-NE, brittleness). In the refined MPST image this becomes a family of
        per-role \emph{obligations} on the trace, not a vector we can later
        quantify over.

  \item \textbf{Counterfactual / strategy-based queries.} \KFOL{} lets us ask
        “if player \(j\) had played differently, would \(i\) still have obtained
        1?” This is a property of the \emph{game} induced by the prefix, not of
        the set of admissible traces. Refined MPST, being trace-based, does not
        encode these counterfactuals.
\end{enumerate}

In other words, the projection is faithful on the protocol side and on all
constraints that are local-at-some-point, but it necessarily flattens the
game-theoretic layer to trace admissibility.

\paragraph{On expressiveness.}
This construction does \emph{not} prove that \KFOL{} is more expressive than
refined MPST; it shows that every \KFOL{} formula admits a refinement-like
reading for its protocol and local constraints. The extra material that we keep
on the \KFOL{} side (multi-headed outcome, solution concepts) is extra
\emph{analysis} over the same script, not an extra control construct in the
protocol itself.

\subsection{Embedding a Refined MPST Fragment into \KFOL}
\label{sec:embed-rmpst-into-kfol}

To complete the comparison, we describe the converse direction: how a
refined–MPST-style specification can be represented in our calculus. Since
\KFOL{} works with a globally described interaction \emph{but} executes it in a
way that respects only the visibility/causal order (i.e.\ strategies make
choices based on what they are allowed to see, and different compatible
strategy profiles may yield different runs), we restrict attention to the
choreography-style fragment of refined MPST in which the whole interaction is
given as one global sequence of actions, each owned by one participant,
optionally decorated with a logical refinement, and delivered to a set of
receivers. This is precisely the part of MPST that mirrors our “global prefix”
view.

\paragraph{Source fragment.}
Consider a refined MPST global of the following shape:
\[
  G \;=\;
  a_1;\; a_2;\; \dots;\; a_n;\; \mathbf{end}
\]
where each action
\[
  a_k \equiv p_k \to \{q_{k,1},\dots,q_{k,m_k}\} : x_k : U_k \{ \psi_k \}
\]
says: participant $p_k$ originates a value $x_k$ of sort $U_k$, to be delivered
to the listed receivers, and the action is subject to a first-order refinement
$\psi_k$ over values introduced by earlier actions. We assume refinements
mention only previously introduced data, as is standard.

\paragraph{Participants.}
Let $\mathcal{P} = \{0,\dots,K-1\}$ be the participant set of $G$. We assume
this is the same participant set as in \KFOL; otherwise we fix a bijection from
names to indices.

\paragraph{Action-to-binder translation.}
We translate each global action to a \KFOL{} binder. For the $k$-th action
\(
  p_k \to \{q_{k,1},\dots,q_{k,m_k}\} : x_k : U_k \{ \psi_k \}
\)
we introduce the binder
\[
  P_{p_k} x_k \setminus V_k.\,\cdot
\]
where
\[
  V_k \;:=\; \mathcal{P} \setminus \bigl(\{p_k\} \cup \{q_{k,1},\dots,q_{k,m_k}\}\bigr)
\]
is exactly the set of roles that are \emph{not} supposed to observe this value.
Intuitively, player $p_k$ now chooses $x_k$, and all non-slashed roles may
condition their later moves on it. This matches the MPST visibility pattern.

\paragraph{Refinements.}
There are two placements for the step refinement $\psi_k$:

\begin{enumerate}[label=(\roman*),nosep]
  \item If we allow an optional guard on binders, we write
        \[
          P_{p_k} x_k \text{ where } \psi_k \setminus V_k.\,\cdot
        \]
        which mirrors the MPST step exactly.
  \item In the core \KFOL{} syntax (no binder guards), we push $\psi_k$ to the
        terminal and conjoin it to those players’ components that must ensure
        (or rely on) that condition. Because \KFOL{} is prenex, $x_1,\dots,x_k$
        are in scope at the terminal.
\end{enumerate}

In both variants, the MPST predicate becomes an FO condition over the same
variables.

\paragraph{Terminal.}
MPST ends in \texttt{end}. In \KFOL{} we must end in a $K$-tuple, so the
simplest embedding is
\[
  \langle \top,\dots,\top \rangle.
\]
If we want the MPST refinements to be seen as “all must hold,” we can instead
take
\[
  \langle \psi_1 \land \dots \land \psi_n,\dots,\psi_1 \land \dots \land \psi_n \rangle,
\]
i.e.\ every participant records that all step conditions were satisfied.

\paragraph{Execution correspondence.}
In MPST, the global script is usually read as prescribing the whole run
sequence. In \KFOL{}, the same script is read as a \emph{visibility-guided}
interaction: each binder introduces data, makes it available to its
non-slashed observers, and strategies for later binders may respond differently
depending on what they saw. Thus, different strategy profiles over the
\KFOL{}-encoded script may realize different admissible runs of the original
MPST script, but always in a way that respects the same causal/visibility
structure.

\paragraph{Expressiveness boundary.}
This embedding is faithful for the linear, non-branching, choreography-style
fragment of refined MPST. Features that go beyond this fragment do not embed
without extending \KFOL{}:
\begin{itemize}[nosep]
  \item \emph{Branching/choice} would require a choice construct in the prefix
        or an encoding via values and guards.
  \item \emph{Recursion/infinite sessions} would require iterative or recursive
        structure.
  \item \emph{Asynchronous channel behaviour} is not represented, since our
        execution model is strategy-driven under a single global interaction
        description, not FIFO-channel–driven.
\end{itemize}
Within the overlapping fragment, however, the translation preserves
participants, causal/visibility dependencies, and the first-order content of
step refinements.
